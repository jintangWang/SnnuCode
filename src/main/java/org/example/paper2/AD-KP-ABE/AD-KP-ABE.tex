\documentclass[runningheads]{llncs}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\setlength{\parindent}{1em}
\usepackage{graphicx}
\begin{document}
\title{Efficient attribute-based encryption with attribute revocation
for assured data deletion}
\section{Construction}
A concrete construction of key-policy attribute-based encryption for assured data deletion is proposed in this part, which supports fine-grained access control simultaneously. In our construction, to achieve assured deletion efficiently, the access structure attached in a private key consists of AND-gate on the attributes. We introduce a special attribute called â€œavailability" in the attribute set. It has two values, namely, available and unavailable. By default, the value available is included in the access structure of users and described attributes in ciphertext. By changing the value of this specific attribute in the ciphertext, the ciphertext will not satisfy the access structure of all users, including the data owner. Hence, the goal of data deletion is achieved. To achieve assured data deletion, the data owner builds a MHT on the components of ciphertext, generates the root of MHT, and uploads the ciphertext, signature of the root to the cloud. When a ciphertext is re-encrypted, the new root of the MHT can be viewed as a proof of deletion. The details of the proposed protocol are as follows.

Let $G_1,G_2$ be two cyclic multiplicative groups with prime order $p$ and $e:G_1\times G_1\to G_2$ be a bilinear map. We use $\Omega=$ $\{att_1,att_2,\cdots att_n\}$ to denote the set of all the possible attributes, and $A_i=\{v_{i,1},v_{i,2},\cdots v_{i,n_l}\}$ to denote all possible values corresponding to attribute $A_{\mathrm{i}}$ where $n_i=|A_i|.$ Let $W=[w_1,w_2,\cdots w_k]$ be an access structure and $\gamma=[\gamma_1,\gamma_2,\cdots\gamma_t]$ be the set of attributes in the ciphertext. We define $\gamma\vDash W$ if attribute set $\gamma$ satisfies the access structure $W$,or else,$\gamma\not\models W.H:\{0$, $1\}^*\to Z_q$ is a hash function used to construct MHT.

Setup (1$^k):$ TA chooses two cyclic multiplicative groups $G_1,G_2$ with order $p$, and a bilinear map $e:G_1\times G_1\to G_2.$ TA randomly chooses $h\in G_1,y\in Z_p$ and computes $Y=e(g,h)^y.$ Then TA picks random $t_ij\in Z_p(i\in[1,n],j\in[1,n_i])$, and computes $T_{i,j}=g^{t,j}(i\in[1,n],j\in[1,n_{i}]).$ The public system parameter is $PK=(e,g,h,Y,\{T_{i,j}\}_{i\in[1,n],j\in[1,n_{i}]})$ and the master secret key is MSK= ( y, $\{ t_{i, j}\} _{i\in [ 1, n] , j\in [ 1, n_{i}] }$) .

KeyGen $(PK,MSK,W){:}$ Given the system parameter PK, master secret key MSK and the access structure $W=$ $[w_1,w_2,\cdots w_k]$, TA picks a random r$\in\mathbb{Z}_p$, computes $g^r$ and $D_w=h^y(g^{\sum_{v_{i,j}\in W}t_{i,j}})^r$, and returns the private key SK$_W=$ $(g^r,D_w,W).$ The data owner generates a signing public-secret key pair $\{spk, ssk\}$, chooses a random $\alpha\leftarrow Z_p$, and computes $v=g^{\alpha}.$ The private key of the data owner is $SK=(SKw,ssk,\alpha)$.

Encrypt $(PK,\gamma,M){:}$ Given the public system parameter PK, a message M and a set of attributes $\gamma$,the data owner picks a random $s\in\mathbb{Z}_p$, then computes $C_1=M\cdot Y^s,C_2=g^s$ and $C_3=(\forall v_{i,j}\in\gamma,X_{i,j}=T_{i,j}^s)$, and outputs the ciphertext CT= $(C_{1},C_{2},C_{3}).$The data owner builds a MHT whose leave nodes are an ordered set of $\vec{H}(x_{ij})$, where $X_\mathrm{ij}\in C_3$ and obtains the MHT root R. Then, the data owner signs R using the signing private key ssk and obtains sig$_{ssk}(R).$ We denote $\tilde{X}$ as the attribute availability in $C_3$, and ind as the index of attribute availability in the leaf nodes of the MHT. To generate a tag for a message $M$, data owner first chooses a unique name fname and generates a tag as $\sigma=(H(fname\parallel ind\parallel\tilde{X}))^\alpha.$ Finally, the data owner uploads $\{fname,ind,CT,\sigma,AAI,sig_{ssk}(R)\}$ to the cloud, where AAI denotes the auxiliary authentication information of $\tilde{X}$ which corresponds to the attribute availability.

Decrypt $(PK,CT,SK){:}$ Given ciphertext $CT$, public system parameter $PK$, and user's private key SK, for $AS\subseteq\gamma,AS=W$, the user compute:
$$\begin{aligned}&\frac{C_{1}\cdot e(\prod_{v_{i,j}\in\gamma}X_{i,j},g^{r})}{e(C_{2},h^{y}(g^{\sum_{v_{i,j}ew}t_{i,j}})^{r})}\\&=\frac{M\cdot e(g,h)^{sy}e((\prod_{v_{i,j}\in\gamma}T_{i,j})^{s},g^{r})}{e(g^{s},h^{y}(g^{\sum_{v_{i,j}ew}t_{i,j}})^{r})}\\&=\frac{M\cdot e(g,h)^{sy}e(g,g)^{sr\sum_{v_{i,j}e\gamma}t_{i,j}}}{e(g,h)^{sy}e(g,g)^{sr\sum_{v_{i,j}ew}t_{i,j}}}\\&=M\end{aligned}$$

DelRequest $(\gamma){:}$ When a data owner wants to delete the outsourced data in the cloud,the owner first sends TA the attributes that need to be modified. Here, the data owner sends the deletion request $DR=(fname,att_i,v_{i,j},v_{i,j}^{\prime})$ to the TA, where $att_i$ denotes the attribute of availability, the value of $\nu_{i,j}$ is "available", and $\upsilon_{i,j}^{\prime}$ is "unavailable". DR= $(fname,att_{i},v_{i,j},v_{i,j}^{\prime})$ means the data owner wants to modify the attribute availability in the ciphertext from "available" to "unavailable": Then the data owner sends the cloud server data retrieval request $\{fname,att_i\}$ where $att_i$ denotes the attribute of availability. The cloud server returns $\{ \tilde{X} , \sigma , ind, \Omega _{ind}, \mathrm{sig}_{ssk}(R) \}$ corresponding to the $att_i$ to the data owner. $\Omega _{ind}$ denotes the auxiliary authentication information of the node ind. After receiving the message from the cloud, the data owner verifies if $e(\sigma,g)=e(H(fname\parallel ind\parallel\widetilde{X}),v)$ holds.If it holds, the $\widetilde{X}$ is indeed the ciphertext component for the attribute availability. Then the data owner utilizes $\widetilde{X}$ and $\Omega_{ind}$ to generate the root $R^\prime$ of the MHT, and verifies if $sig_{ssk}(R)=\operatorname{sig}_{ssk}(R^{\prime})$ holds. If the equation holds, the $\Omega_{ind}$ is a valid AAI of $\widetilde{X}.$


ReKeyGen $(DR,MSK):$ Given master secret key MSK and the deletion request, TA chooses a random $t_{i,j}^{\prime}$ and calculates $ck_{i}=\frac{t_{i,j}^{\prime}}{t_{i,j}}.$Then,TA sends $rk=(fname,att_{i},ck_{i})$ to the data owner. Upon receiving rk, the data owner forwards rk to the cloud server.

ReEncrypt $(CT,rk):$ Given ciphertext CT, proxy re-encryption key rk, the cloud server computes $\widetilde{X}^{\prime}=\widetilde{X}^{ck_i}$ for $\nu_{i,j}\in rk$, and replaces the $\widetilde{X}$ in the original ciphertext with the $\widetilde{X}^{\prime}.$ Then the cloud server outputs the new ciphertext $CT^{\prime}=(C_1,C_2,C_3^{\prime},\gamma^{\prime}).$ Finally, the cloud server computes $H(\tilde{X}^{\prime})$, generates new root of the MHT $\hat{R}$, and returns $\hat{R}$ to the data owner as a proof of deletion.

Verify $(AAI,\hat{R})$: To verify the cloud server indeed deletes the data, the data owner re-encrypts $\tilde{X}$ using rk, and obtains $\overrightarrow{X}.$ The data owner also runs the MHT updating algorithm to get the new root value for comparison with the one sent by the server. Upon receiving $\hat{R}$, the data owner utilizes $\overrightarrow{X}$ and AAI $\Omega_\mathrm{ind}$ received from the cloud server to generate the new root $\overrightarrow{R}$ of the MHT. If $\overrightarrow{R}=\hat{R}$ holds, it indicates that the cloud server has indeed deleted the data.


\end{document}
